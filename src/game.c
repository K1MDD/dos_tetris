/*	Game.c
	Includes functions for creating, moving, and drawing tetris pieces, as well as setting up the title, pause, and high score screens
	Part of Tetris clone
	Marcus Drab
	2/28/2019*/

#include "..\include\game.h"
#include "..\include\screen.h"
#include "..\include\timer.h"
#include "..\include\input.h"
#include "..\include\disk.h"

#include <stdlib.h>

#define OLD_PIECE 1
#define NEW_PIECE 2
#define INTERSECTION 3

char stats[7] = {0, 0, 0, 0, 0, 0, 0};		//


char title[11][78] = {
		{0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20, 0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20, 0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20, 0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20, 0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20, 0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20},
		{0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD},
		{0x20, 0xDF, 0xDF, 0xDF, 0xDF, 0xDB, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0x20, 0xDE, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20, 0x20, 0xDF, 0xDF, 0xDF, 0xDF, 0xDB, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0x20, 0xDE, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDB, 0xB2, 0xDD, 0x20, 0xDF, 0xDF, 0xDF, 0xDF, 0xDB, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0x20, 0xDE, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20},
		{0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
		{0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDB, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDB, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDB, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDB, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20},
		{0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD},
		{0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0xDB, 0xB2, 0xDF, 0xDF, 0xDF, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDB, 0xB2, 0xDD},
		{0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD},
		{0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDB, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDB, 0xB2, 0xDB, 0xDC, 0xDC, 0xDC, 0xDC, 0x20, 0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDB, 0xB2, 0xDD},
		{0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD},
		{0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDF, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDF, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDF, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDF, 0x20, 0x20, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20, 0x20, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20}
	};

void init_pause_screen(void)
{
	char pause[11][65] = {
		{0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20, 0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20, 0x20, 0xDC, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDC, 0x20, 0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20, 0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20},
		{0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD},
		{0xDE, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDB, 0xB2, 0xDD, 0xDE, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDB, 0xB2, 0xDD, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0xDE, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20, 0xDE, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20},
		{0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
		{0xDE, 0xB2, 0xDB, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDB, 0xB2, 0xDD, 0xDE, 0xB2, 0xDB, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDB, 0xB2, 0xDD, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0xDE, 0xB2, 0xDB, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20, 0xDE, 0xB2, 0xDB, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20},
		{0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD},
		{0xDE, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20, 0xDE, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDB, 0xB2, 0xDD, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDB, 0xB2, 0xDD, 0xDE, 0xB2, 0xDB, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20},
		{0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
		{0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0xDE, 0xB2, 0xDB, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDB, 0xB2, 0xDD, 0x20, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDB, 0xB2, 0xDD, 0xDE, 0xB2, 0xDB, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0x20},
		{0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDE, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD, 0xDE, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xDD},
		{0x20, 0xDF, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDF, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0xDF, 0x20, 0x20, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20, 0x20, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20, 0x20, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0xDF, 0x20}
	};
	unsigned char i, j;
	
	for(i = 0; i < 11; i++){
		for(j = 0; j < 65; j++){
		move_cursor(3 + i, 8 + j, 1);
		write_char(pause[i][j], 1, 1, j / 13 + 2);
		}
	}
	draw_frame(5, 2, 70, 19, 1);
	write_string(18, 29,"Press P to resume game", 1, white);
	
}

void update_stats(PIECE_TYPE type)
{
	unsigned char i;
	char types[7] = {I, T, O, S, Z, J, L};
	for(i = 0; i < 7; i++){
		if(type == types[i]){
			stats[i]++;
			write_num(4 + i * 3, 73, stats[i], 0, white);
		}
	}
}

void title_screen(void)
{
	char lines_scrolled = 0;
	unsigned char i, j;
	
	for(i = 0; i < 11; i++){
		for(j = 0; j < 78; j++){
		move_cursor(1 + i, 1 + j, 2);
		write_char(title[i][j], 1, 2, j / 13 + 1);
		move_cursor(1 + i, 1 + j, 3);
		write_char(title[i][j], 1, 3, j / 13 + 9);
		
		}
	}
	
	clock_ticks = 0;
	change_page(2);
	while(clock_ticks < 30);
	write_string(12, 30, "A clone by Marcus Drab", 2, white);
	write_string(12, 30, "A clone by Marcus Drab", 3, white);
	clock_ticks = 0;
	while(clock_ticks < 30);
	write_string(16, 35, "Controls:", 2, red);
	write_string(17, 32, "A: Move piece left", 2, white);
	write_string(18, 32, "S: Move piece down", 2, white);
	write_string(19, 32, "D: Move piece right", 2, white);
	write_string(20, 32, "Space: Rotate piece", 2, white);
	write_string(21, 32, "P: Pause game", 2, white);
	write_string(22, 32, "Q: Quit game", 2, white);
	write_string(16, 35, "Controls:", 3, red);
	write_string(17, 32, "A: Move piece left", 3, white);
	write_string(18, 32, "S: Move piece down", 3, white);
	write_string(19, 32, "D: Move piece right", 3, white);
	write_string(20, 32, "Space: Rotate piece", 3, white);
	write_string(21, 32, "P: Pause game", 3, white);
	write_string(22, 32, "Q: Quit game", 3, white);
	clock_ticks = 0;
	while(clock_ticks < 15);
	write_string(14, 26, "Press space bar to start game", 2, yellow);
	write_string(14, 26, "Press space bar to start game", 3, yellow);
	
	clock_ticks = 0;
	while(key != ' '){
		if(clock_ticks == 15){
			change_page(3);
		}if(clock_ticks >= 30){
			clock_ticks = 0;
			change_page(2);
		}
	}
	clock_ticks = 0;
	do{
		if(clock_ticks > 1){
			clock_ticks = 0;
			scroll_page_up(1);
			lines_scrolled++;
		}
	}while(lines_scrolled < 25);
	change_page(0);
}

void show_high_scores(char user_score, unsigned char score_index)
{
	unsigned char i, j;
	
	change_page(3);
	init_screen();
	change_page(0);
	draw_frame(5, 2, 70, 11, 3);
	for(i = 0; i < 11; i++){
		for(j = 0; j < 78; j++){
		move_cursor(14 + i, 1 + j, 3);
		write_char(title[i][j], 1, 3, j / 13 + 1);
		}
	}
	write_string(2, 33, "High Scores:", 3, red);
	for(i = 0; i < 10; i++){
		for(j = 0; j < 3; j++){
			move_cursor(3 + i,5 + j, 3);
			write_char(scores[i].initials[j], 1, 3, white);
		}
		move_cursor(3 + i, 8, 3);
		write_char('.', 60, 3, white - ((user_score && i == score_index) ? 1 : 0));
		write_num(3+i, 68, scores[i].score, 3, white - ((user_score && i == score_index) ? 1 : 0));
	}
	change_page(3);
	if(user_score){
		write_string(0, 5, "Enter your initials:", 3, white);
		key = 0;
		while(!key);
		move_cursor(3 + score_index, 5, 3);
		scores[score_index].initials[0] = key;
		write_char(scores[score_index].initials[0], 1, 3, yellow);
		key = 0;
		while(!key);
		move_cursor(3 + score_index, 6, 3);
		scores[score_index].initials[1] = key;
		write_char(scores[score_index].initials[1], 1, 3, yellow);
		key = 0;
		while(!key);
		move_cursor(3 + score_index, 7, 3);
		scores[score_index].initials[2] = key;
		write_char(scores[score_index].initials[2], 1, 3, yellow);
	}
	write_string(0, 5, "Press any key to quit.", 3, white);
	key = 0;
	while(!key);
}

void init_stats(void)
{
	unsigned char i;
	write_string(2, 60, "Stats:", 0, white);
	for(i = 0; i < 7; i++){
		write_num(4 + i * 3, 73, 0, 0, white);
	}
}

TETRIS_PIECE gen_piece(PIECE_TYPE prev_type)
{
	TETRIS_PIECE p;
	p.type = gen_type(prev_type);
	p.r = up;
	p.y = 0;
	p.x = (p.type == I) ? 3 : 4;
	return(p);
}

PIECE_TYPE gen_type(PIECE_TYPE prev_type)
{
	unsigned char rnd;
	char types[8] = {I, T, O, S, Z, J, L, 0};
	srand(clock_ticks_since_midnight());
	rnd = rand() / 4681;
	if(rnd == 7 || types[rnd] == prev_type){
		return(types[rand() / 5461]);
	}
	else{
		return(types[rnd]);
	}
}

PIECE_GRID get_piece_grid(TETRIS_PIECE p, unsigned char x_offset, unsigned char y_offset, char n)
{
	PIECE_GRID grid = {{
		{0, 0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 0, 0}
	}};
	
	unsigned char i;
	
	switch(p.type){
		case O:
			grid.a[y_offset][x_offset] = n;
			grid.a[y_offset + 1][x_offset] = n;
			grid.a[y_offset][x_offset + 1] = n;
			grid.a[y_offset + 1][x_offset + 1] = n;
			break;
		case T:
			switch(p.r){
				case up:
					for(i = x_offset; i < x_offset + 3; i++){
						grid.a[y_offset][i] = n;
					}
					grid.a[y_offset + 1][x_offset + 1] = n;
					break;
				case right:
					for(i = y_offset; i < y_offset + 3; i++){
						grid.a[i][x_offset + 1] = n;
					}
					grid.a[y_offset + 1][x_offset] = n;
					break;
				case down:
					for(i = x_offset; i < x_offset + 3; i++){
						grid.a[y_offset + 1][i] = n;
					}
					grid.a[y_offset][x_offset + 1] = n;
					break;
				case left:
					for(i = y_offset; i < y_offset + 3; i++){
						grid.a[i][x_offset] = n;
					}
					grid.a[y_offset + 1][x_offset + 1] = n;
					break;
				default:
					break;
			}
			break;
		case S:
			switch(p.r){
				case up:
					grid.a[y_offset][x_offset + 1] = n;
					grid.a[y_offset + 1][x_offset] = n;
					grid.a[y_offset][x_offset + 2] = n;
					grid.a[y_offset + 1][x_offset + 1] = n;
					break;
				case right:
					grid.a[y_offset][x_offset] = n;
					grid.a[y_offset + 1][x_offset] = n;
					grid.a[y_offset + 1][x_offset + 1] = n;
					grid.a[y_offset + 2][x_offset + 1] = n;
					break;
				case down:
					grid.a[y_offset][x_offset + 1] = n;
					grid.a[y_offset + 1][x_offset] = n;
					grid.a[y_offset][x_offset + 2] = n;
					grid.a[y_offset + 1][x_offset + 1] = n;
					break;
				case left:
					grid.a[y_offset][x_offset] = n;
					grid.a[y_offset + 1][x_offset] = n;
					grid.a[y_offset + 1][x_offset + 1] = n;
					grid.a[y_offset + 2][x_offset + 1] = n;
					break;
				default:
					break;
			}
			break;
		case I:
			switch(p.r){
				case up:
					for(i = x_offset; i < x_offset + 4; i++){
						grid.a[y_offset][i] = n;
					}
					break;
				case right:
					for(i = y_offset; i < y_offset + 4; i++){
						grid.a[i][x_offset] = n;
					}
					break;
				case down:
					for(i = x_offset; i < x_offset + 4; i++){
						grid.a[y_offset][i] = n;
					}
					break;
				case left:
					for(i = y_offset; i < y_offset + 4; i++){
						grid.a[i][x_offset] = n;
					}
					break;
				default:
					break;
			}
		break;
		case Z:
			switch(p.r){
				case up:
					grid.a[y_offset][x_offset] = n;
					grid.a[y_offset][x_offset + 1] = n;
					grid.a[y_offset + 1][x_offset + 2] = n;
					grid.a[y_offset + 1][x_offset + 1] = n;
					break;
				case right:
					grid.a[y_offset][x_offset + 1] = n;
					grid.a[y_offset + 1][x_offset] = n;
					grid.a[y_offset + 1][x_offset + 1] = n;
					grid.a[y_offset + 2][x_offset] = n;
					break;
				case down:
					grid.a[y_offset][x_offset] = n;
					grid.a[y_offset][x_offset + 1] = n;
					grid.a[y_offset + 1][x_offset + 2] = n;
					grid.a[y_offset + 1][x_offset + 1] = n;
					break;
				case left:
					grid.a[y_offset][x_offset + 1] = n;
					grid.a[y_offset + 1][x_offset] = n;
					grid.a[y_offset + 1][x_offset + 1] = n;
					grid.a[y_offset + 2][x_offset] = n;
					break;
				default:
					break;
			}
			break;
		case J:
			switch(p.r){
				case up:
					for(i = x_offset; i < x_offset + 3; i++){
						grid.a[y_offset][i] = n;
					}
					grid.a[y_offset + 1][x_offset + 2] = n;
					break;
				case right:
					for(i = y_offset; i < y_offset + 3; i++){
						grid.a[i][x_offset + 1] = n;
					}
					grid.a[y_offset + 2][x_offset] = n;
					break;
				case down:
					for(i = x_offset; i < x_offset + 3; i++){
						grid.a[y_offset + 1][i] = n;
					}
					grid.a[y_offset][x_offset] = n;
					break;
				case left:
					for(i = y_offset; i < y_offset + 3; i++){
						grid.a[i][x_offset] = n;
					}
					grid.a[y_offset][x_offset + 1] = n;
					break;
				default:
					break;
			}
		break;
		
		case L:
			switch(p.r){
				case up:
					for(i = x_offset; i < x_offset + 3; i++){
						grid.a[y_offset][i] = n;
					}
					grid.a[y_offset + 1][x_offset] = n;
					break;
				case right:
					for(i = y_offset; i < y_offset + 3; i++){
						grid.a[i][x_offset + 1] = n;
					}
					grid.a[y_offset][x_offset] = n;
					break;
				case down:
					for(i = x_offset; i < x_offset + 3; i++){
						grid.a[y_offset + 1][i] = n;
					}
					grid.a[y_offset][x_offset + 2] = n;
					break;
				case left:
					for(i = y_offset; i < y_offset + 3; i++){
						grid.a[i][x_offset] = n;
					}
					grid.a[y_offset + 2][x_offset + 1] = n;
					break;
				default:
					break;
			}
			break;
		default:
			break;
	}
	return grid;
}

PIECE_GRID get_intersection(PIECE_GRID old_piece, PIECE_GRID new_piece)
{
	PIECE_GRID g;
	unsigned char i;
	unsigned char j;
	for(i = 0; i < 7; i++){
		for(j = 0; j < 7; j++){
			g.a[i][j] = old_piece.a[i][j] + new_piece.a[i][j];
		}
	}
	return(g);
}

char get_width(PIECE_GRID g)
{
	unsigned char i;
	unsigned char j;
	char start = 99;
	char end = 0;
	
	for(i = 0; i < 7; i++){
		for(j = 0; j < 7; j++){
			if((g.a[i][j]) ? 1 : 0){
				start = (start > j) ? j : start;
				end = (j > end) ? j : end;
			}
		}
	}
	return(end - start + 1);
}

char get_height(PIECE_GRID g)
{
	unsigned char i;
	unsigned char j;
	char start = 99;
	char end = 0;
	
	for(i = 0; i < 7; i++){
		for(j = 0; j < 7; j++){
			if(g.a[j][i]){
				start = (start > j) ? j : start;
				end = (j > end) ? j : end;
			}
		}
	}
	return(end - start + 1);
}

char draw_piece(TETRIS_PIECE p)
{

	char c = 0;

	int i;
	int j;
	PIECE_GRID grid = get_piece_grid(p, 0, 0, 1);
	BOX_COORDINATES b;
	for(i = 0; i < get_height(grid); i++){
		for(j = 0; j < get_width(grid); j++){
			if(grid.a[i][j]){
				b.x = p.x + j;
				b.y = p.y + i;
				c = (check_box(b) == 0x20) ? 0 : 1;
				draw_box(b, p.type);		
			}
		}
	}
	return(c);
}

void draw_next_piece(char x, char y, TETRIS_PIECE p)
{
	int i;
	int j;
	BOX_COORDINATES b;
	PIECE_GRID grid = get_piece_grid(p, 0, 0, 1);
	for(i = 0; i < 2; i++){
		for(j = 0; j < 4; j++){
				b.x = x + j;
				b.y = y + i;
				del_box(b);
			if(grid.a[i][j]){
				draw_box(b, p.type);
			}
		}
	}
}

TETRIS_PIECE draw_intersection(TETRIS_PIECE old_piece, TETRIS_PIECE new_piece){
	unsigned char i, j;
	BOX_COORDINATES b;
	PIECE_GRID prev_grid = get_piece_grid(old_piece, 2, 2, OLD_PIECE);
	PIECE_GRID current_grid = get_piece_grid(new_piece, 2 + (new_piece.x - old_piece.x), 2 + (new_piece.y - old_piece.y), NEW_PIECE);
	PIECE_GRID intersection = get_intersection(prev_grid, current_grid);
	for(i = 0; i < 7;i++){
		for(j = 0;j < 7;j++){
			if(intersection.a[i][j] == NEW_PIECE){
				b.x = old_piece.x - 2 + j;
				b.y = old_piece.y - 2 + i;
				if(b.x > 9 || b.y > 19 || check_box(b) != 0x20){
					return(old_piece);
				}
			}
		}
	}
	for(i = 0; i < 7;i++){
		for(j = 0;j < 7;j++){
			if(intersection.a[i][j] == OLD_PIECE){
				b.x = old_piece.x - 2 + j;
				b.y = old_piece.y - 2 + i;
				del_box(b);
			}else if(intersection.a[i][j] == NEW_PIECE){
				b.x = old_piece.x - 2 + j;
				b.y = old_piece.y - 2 + i;
				draw_box(b, new_piece.type);
			}
		}
	}
	return(new_piece);
}

TETRIS_PIECE rotate_piece(TETRIS_PIECE p)
{
	TETRIS_PIECE prev_piece = p;
	
	if(p.r == right){
		p.r = up;  
	}else{
		p.r += 1;
	}
	
	switch(p.type){
		case I:
			if(p.r == up || p.r == down){
				p.x -= 2;
				p.y += 2;
			}else{
				p.x += 2;
				p.y -= 2;
			}
			break;
		case T:
			switch(p.r){
				case up:
					p.y += 1;
					break;
				case left:
					p.x += 1;
					p.y -= 1;
					break;
				case down:
					p.x -= 1;
					break;
				default:
					
				break;
			}
			break;
		case S:
		case Z:
			if(p.r == up || p.r == down){
				p.x -= 1;
				p.y += 1;
			}else{
				p.x += 1;
				p.y -= 1;
			}
			break;
		case J:
		case L:
			switch(p.r){
				case up:
					p.y++;
					break;
				case left:
					p.x += 1;
					p.y -= 1;
					break;
				case down:
					p.x -= 1;
					break; 
				default:
					
					break;
			}
		default:
		break;
	}
	
	p = draw_intersection(prev_piece, p);
	return(p);
}



TETRIS_PIECE move_piece_left(TETRIS_PIECE p)
{
	TETRIS_PIECE prev_piece = p;
	p.x--;
	p = draw_intersection(prev_piece, p);
	return(p);
}

TETRIS_PIECE move_piece_right(TETRIS_PIECE p)
{
	TETRIS_PIECE prev_piece = p;
	p.x++;
	p = draw_intersection(prev_piece, p);
	return(p);
}

TETRIS_PIECE move_piece_down(TETRIS_PIECE p)
{
	TETRIS_PIECE prev_piece = p;
	p.y++;
	p = draw_intersection(prev_piece, p);
	return(p);
}


